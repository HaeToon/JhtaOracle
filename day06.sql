--제약 조건  create table 
CREATE TABLE USER_TABLE (
   userid varchar2(20) NOT NULL,
   userpw varchar2(20) NOT NULL,
   cp     varchar2(20)
);

--  validation  -- front에서 거르기 -- back -- db
SELECT * FROM user_table;
INSERT INTO user_table (userid, userpw, cp) 
VALUES ('jjang051','1234','');
-- 제약 조건은 crud 다 안됨
UPDATE user_table SET userid = NULL WHERE userid = 'jjang051'; --USER ID 에 NOT NULL 제약조건을 걸었기때문에 USERID 를 NULL로 UPDATE할수 없다.

SELECT * FROM user_constraints;

DROP TABLE user_table CASCADE constraints;

CREATE TABLE USER_TABLE (
   userid varchar2(20) CONSTRAINT user_table_userid_not_null NOT NULL,
   userpw varchar2(20) CONSTRAINT user_table_userpw_not_null NOT NULL,
   cp     varchar2(20)
);
-- 제약 조건 만들때 처음부터 잘 생각하고 만드는게 좋다.
-- 나중에 바꿀때는 기존 들어가 있는 값이 제약 조건에 하나라도 위배 되면
-- 안됨...
INSERT INTO user_table (userid, userpw, cp) 
VALUES ('jjang053','1234',null);

select * FROM user_table;

UPDATE user_table SET cp = '010-1111-2222';


ALTER TABLE USER_TABLE 
modify(cp constraint user_table_cp_not_null NOT NULL); --CP의 제약조건을 NOT NULL로 MODIFY 했기때문에 USER_TABLE의CP값은 NULL이 될수없다.
UPDATE user_table SET cp = NULL;
-- 제약조건 지울때... 손에 익어지면 된다.
ALTER TABLE USER_TABLE
DROP constraint user_table_cp_not_null;  -- CP의 제약조건을 DROP 했기때문에 USER_TABLE의 CP값을 NULL 처리할수있다.
UPDATE user_table SET cp = NULL;


CREATE TABLE table_unique (
   userid varchar2(20) UNIQUE,
   userpw varchar2(20) NOT NULL,
   cp     varchar2(20)
);

SELECT * FROM table_unique;

INSERT INTO table_unique (userid, userpw, cp) VALUES
(null,'1234','010-1111-1111');
SELECT * FROM table_unique; -- null은 unique에서 예외


UPDATE table_unique SET userid = 'jjang053'
WHERE userid IS NULL;

DROP TABLE user_table CASCADE constraints;


-- unique, not null  primary key

CREATE TABLE table_prmary (
   userid varchar2(20) PRIMARY key, --  UNIQUE, NOT null
   userpw varchar2(20) NOT NULL,
   cp     varchar2(20) 
);
ALTER TABLE table_prmary RENAME TO table_primary;

SELECT * FROM table_primary;

DROP TABLE table_primary;

--unique , not null 동시에 거는 primary key
CREATE TABLE TABLE_PRIMARY (
USERID VARCHAR2(20) PRIMARY KEY , --UNIQUE , NOTNULL
USERPW VARCHAR2(20) NOT NULL,
CP VARCHAR2(20)
);

DROP TABLE TABLE_PRIMARY;

CREATE TABLE TABLE_PRIMARY (
USERID VARCHAR2(20),  --UNIQUE , NOTNULL
USERPW VARCHAR2(20), 
CP VARCHAR2(20),
PRIMARY KEY (USERID),
UNIQUE (CP)
--NOT NULL (USERPW) NOT NULL 은 안됨
);

--PRIMARY KEY 제약조건을 걸면 INDEXING도 해준다.
INSERT INTO TABLE_PRIMARY (USERID,USERPW,CP)VALUES('GXG4205','1234','010-1111-1111');

SELECT * FROM TABLE_PRIMARY;

SELECT * FROM DEPT;
--FOREIGN KEY 
INSERT INTO EMP (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,DEPTNO)
VALUES (9999,'TAEHOON','STUDENT',1111,'2024-05-03',3000,50); -- EMP 와 DEPT 의 DEPTNO에 공통되는 값이 없다.
ROLLBACK;
SELECT * FROM EMP;

--FOREIGN KEY 는 부모 테이블에 PRIMARY KEY 설정하고 그걸 참조해서 만든다.

CREATE TABLE FK_DEPT (
DEPTNO NUMBER(2) CONSTRAINT FK_DEPT_PK PRIMARY KEY, --제약조건에 
DNAME VARCHAR2(20),
LOC VARCHAR2(20)
);

CREATE TABLE FK_EMP (
	EMPNO NUMBER(4) CONSTRAINT FK_EMP_PK PRIMARY KEY,
	ENAME VARCHAR2(20),
	JOB VARCHAR2(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7,2),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2) CONSTRAINT FK_EMP_FOREIGNKEY REFERENCES
	FK_DEPT(DEPTNO) ON DELETE CASCADE -- ON DELETE CASCADE 삭제 할때 참조되는 COLUMN도 삭제하는 것.
);

--FOREIGN KEY 는 부모COLUMN에 있는 값만 쓸수있다.
INSERT INTO FK_DEPT VALUES(10,'BACKEND','SEOUL');
INSERT INTO FK_EMP VALUES(9999,'TAEHOON','STUDENT',1111,SYSDATE,3000,NULL,10);

SELECT * FROM FK_DEPT;
SELECT * FROM FK_EMP;

DELETE FROM FK_DEPT WHERE DEPTNO=40; -- DEPTNO = 40 을 참조하는 행이 존재하므로 삭제 불가능
DELETE FROM FK_DEPT WHERE DEPTNO=50; -- DEPTNO = 50 을 참조하는 행이 존재하므로 삭제 불가능
DELETE FROM FK_DEPT WHERE DEPTNO=80; -- DEPTNO = 80 을 참조 자식값이 없으므로 삭제가능

DELETE FROM FK_EMP WHERE DEPTNO=40; -- DEPTNO = 40 를삭제
DELETE FROM FK_DEPT WHERE DEPTNO=40; -- DEPTNO = 40 을 쓰는 행을 삭제했으므로 삭제가능

DROP TABLE FK_DEPT CASCADE CONSTRAINTS; -- CASCADE CONSTRAINTS 는 참조되는 제약사항들을 모두 삭제 (FOREIGN KEY)  
DROP TABLE FK_EMP CASCADE CONSTRAINTS; -- CASCADE CONSTRAINTS 는 참조되는 제약사항들을 모두 삭제 (FOREIGN KEY)  

DELETE FROM FK_DEPT WHERE DEPTNO=10; -- FK_EMP를 생성할때 ON DELETE CASCADE 로 인해 부모테이블의 ROW 삭제시 자식테이블의 참조되는 ROW들도 모두 삭제된다.  

CREATE TABLE CHECK_TABLE (
	USERID VARCHAR2(20) CONSTRAINT CHECK_TABLE_PK PRIMARY KEY,
	USERPW VARCHAR2(20) CONSTRAINT CHECK_TABLE_CK CHECK (LENGTH(USERPW) >=8),
	CP VARCHAR2 (13)
);
DROP TABLE CHECK_TABLE;
INSERT INTO CHECK_TABLE VALUES ('GXG4205','1234','010-1111-2222'); -- CHECK 제약인 LENGTH(USERPW)가 8미만이기때문에 불가능.
INSERT INTO CHECK_TABLE VALUES ('GXG4205','12345678','010-1111-2222'); -- CHECK 제약인 LENGTH(USERPW)가 8이상이기때문에 가능.

SELECT * FROM CHECK_TABLE;

SELECT * FROM USER_CONSTRAINTS; --제약조건들 확인하기
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE '%CHECK_TABLE%';

CREATE TABLE DEFAULT_TABLE (
	USERID VARCHAR2(20) CONSTRAINT DEFAULT_TABLE_PK PRIMARY KEY,
	USERPW VARCHAR2(20) DEFAULT '1234',
	CP VARCHAR2 (13) DEFAULT '010-0000-0000'
);
INSERT INTO DEFAULT_TABLE VALUES('TAEHOON',NULL,NULL);
INSERT INTO DEFAULT_TABLE (USERID)VALUES('TAEHOON2'); --COLUMN에 값을 넣지 않았을때 DEAFULT 값이 들어감.
SELECT * FROM DEFAULT_TABLE;


--1-1 DEPT_CONST
CREATE TABLE DEPT_CONST (
	DEPTNO NUMBER(2) CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
	DNAME VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE,
	LOC VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL
);
--1-1 AN
CREATE TABLE DEPT_CONST(
	DEPTNO NUMBER(2) CONSTRAINT DEPTCONST_DEPNO_PK PRIMARY KEY ,
	DNAME VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE,
	LOC VARCHAR2(13) CONSTRAINT DEPTCONST_LIC_NN NOT NULL
);

--1-2 EMP_CONST
CREATE TABLE EMP_CONST (
	EMPNO NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
	ENAME VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
	JOB VARCHAR2(9),
	TEL VARCHAR2(13) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
	HIREDATE DATE,
	SAL NUMBER(7,2) CONSTRAINT EMPCONST_SAL_CK CHECK (SAL BETWEEN 1000 AND 9999),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK  REFERENCES DEPT_CONST(DEPTNO) --DEPT_CONST의DEPTNO를 참조하는 FOREIGN KEY (DEPTNO) 
);

--1-2AN
CREATE TABLE EMP_CONST(
	EMPNO NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
	ENAME VARCHAR2(10) EMPCONST_ENAME_NN NOT NULL,
	JOB VARCHAR2(9),
	TEL VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
	HIREDATE DATE,
	SAL NUMBER(7,2) CONSTRAINT EMPCONST_SAL_CHK CHECK(SAL BETWEEN 1000 AND 9999),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO)
);
--2
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE '%CONST%' ORDER BY TABLE_NAME;
SELECT TABLE_NAME,CONSTRAINT_NAME,CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE '%CONST%' ORDER BY TABLE_NAME;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME IN ('EMP_CONST','DEPT_CONST') ORDER BY TABLE_NAME;

--권한
--SYS계정에서 DB접속권한 >> TABLE 생성능력 , 접속권한, SELECT 권한 ,INSERT 권한,UPDATE 권한 등


--SCOTT 은 계정생성능력을 부여받지않음
CREATE USER JHTA01 IDENTIFIED BY 1234;


















