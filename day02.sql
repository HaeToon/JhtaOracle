--단일행 함수
--행 ROW 열 COLUMN
SELECT * FROM EMP;
SELECT ENAME ,
INITCAP(ENAME) AS "INITCAP",--INITCAP(Column 명) = 해당column의 열값을 대문자로시작하는 소문자로 바꾼다.
UPPER(ENAME)AS "upper",
LOWER(ENAME)AS "lower"
FROM EMP; 
--값은 작은따옴표 '' 문자열은 큰따옴표 ""
SELECT ENAME , LENGTH(ENAME) AS "length" FROM EMP;

SELECT LENGTH('스캇맨'),LENGTHB ('스캇맨'),LENGTH('SCOTT'),LENGTHB('SCOTT') FROM DUAL; --length() 글자수 lengthb 글자의 바이트수 

SELECT CONCAT (ENAME,JOB)FROM EMP;

SELECT ENAME || JOB AS CONCAT FROM EMP;

SELECT SUBSTR(ENAME,1,2)||'...' FROM EMP;

SELECT SUBSTR('동해물과 백두산이 마르고 닳도록 하느님이 보우하사 우리나라만세',1,10)||'...'AS "TITLE" FROM DUAL

SELECT SUBSTR('961007',3)FROM DUAL;  --SUBSTAR(내용,어디,어디까지) 어디까지생략시  나머지 전부 가져오기.
SELECT SUBSTR('961007',-3)FROM DUAL;-- -는 뒤에서부터 셈

--TEST용 TABEL 만들때 WITH
WITH temp AS(
	SELECT 1234 EMPNO,'MICHAEL' ENAME,'MANAGER' JOB FROM DUAL
)
SELECT EMPNO,ENAME, SUBSTR (ENAME,-5,2), JOB,SUBSTR (JOB,1,3) FROM temp ;

SELECT '1-2-3-4', INSTR('1-2-3-4','-',1) FROM DUAL; --INSTR 1-2-3-4의 문자중 -을 1번째문자부터 찾고 있다면 그 자릿수를 리턴함.

--Scott sCott scott sCoTT 
SELECT * FROM EMP WHERE LOWER(ENAME) LIKE LOWER('%SCOTT%');
--뒤에서 3글자만 뽑기
SELECT SUBSTR(JOB,-3) FROM EMP ;

SELECT * FROM EMP WHERE ENAME LIKE '%S%';
SELECT * FROM EMP WHERE INSTR(ENAME,'S',1)>0;

SELECT '010-1111-2222' AS TEL,REPLACE('010-1111-2222','-',' ')AS REPLACE FROM DUAL;

--LPAD , RPAD

SELECT 'ORACLE' AS ORIGINAL , LPAD('oracle',10,'*') FROM DUAL;
--961008=7-1234567 >> 961007-1******;

SELECT '961007-1234567' AS ORIGINAL , RPAD(SUBSTR('801122 - 1234567',1,7),14,'#')FROM DUAL;

---010-1111-2222 허** 010-11**-****
SELECT '010-1111-2222' AS ORIGINAL ,RPAD('010-1',8,'#') || RPAD('-',5,'#') AS RPADNUM FROM DUAL;

-- LPAD 왼쪽에서부터 채우기 RPAD 오른쪽에서부터 채우기 
SELECT ENAME,LPAD(SUBSTR(ENAME,-2),LENGTH(ENAME),'*') FROM EMP;
SELECT ENAME,RPAD(SUBSTR(ENAME,1,2),LENGTH(ENAME),'*') FROM EMP;

SELECT TRIM(' O R A C L E ') AS TRIM FROM DUAL; --TRIM 좌우 공백 삭제 LTRIM좌측 공백 삭제 RTRIM 우측 공백 삭제 

SELECT LTRIM('00001111','0') AS TRIM FROM DUAL;

--숫자함수 오라클엔 INT FLOAT 이런거없음.

SELECT ROUND(1234.56789) FROM DUAL; --ROUND 반올림
SELECT ROUND(4.5678,1) FROM DUAL;
SELECT ROUND(4.5678,2) FROM DUAL;
SELECT ROUND(4.5678,3) FROM DUAL;

SELECT ROUND(1234.5678,-1),ROUND(1234.5678,-2),ROUND(1234.5678,-3) FROM DUAL; 


--TRUNC는 ORACLE 전용함수이다.
SELECT TRUNC(1234.5678),TRUNC(1234.5678,1),TRUNC(1234.5678,2),TRUNC(10) FROM DUAL; --TRUNC 버림

SELECT FLOOR(1234.5678) FROM DUAL;
SELECT FLOOR(1234.5678*10)/10 FROM DUAL;

SELECT CEIL(1234.5678 *10)/10 FROM DUAL;

SELECT CEIL(-2.5)FROM DUAL; -- 음의정수 //-1.5보다 큰 정수
SELECT FLOOR(-1.5)FROM DUAL;

SELECT MOD(10,3) FROM DUAL; --MOD A,B = A/B의교직주앟나네
SELECT MOD(10,6) FROM DUAL;


SELECT ROWNUM AS"NO" ,CEIL(ROWNUM/3) AS"NO", ENAME FROM EMP; --ROWNUM 오라클 순서 패키지  ROWNUM 은 순서셀때 쓴다. ORACLE에는 자동증가가없음. SEQUENCE를만들어서 사용헌더,

SELECT POWER (2,300) FROM DUAL;

--문자함수 숫자함수 살펴봄 

--날짜함수
SELECT SYSDATE AS NOW,SYSDATE -1 AS YESTERDAY,SYSDATE+1 AS TOMMOROW FROM DUAL;

--날짜 함수 사용했는데 시분초뒤가 안나올시 ALTER SESSION SET nls_date_format = 'RRRR-MM-DD:HH24:MI:SS';

SELECT  MONTHS_BETWEEN(SYSDATE , '2002 - 09 - 08') FROM DUAL;

SELECT TRUNC(MONTHS_BETWEEN(SYSDATE,'2002-01-14')) FROM DUAL;

WITH temp AS(
	SELECT 1111 AS NO , '태훈' AS NAME , '2020-03-09' AS HIREDATE FROM DUAL 
	UNION ALL 
	SELECT 1111 AS NO , '우연' AS NAME , '2019-04-16' AS HIREDATE FROM DUAL
)
--몇년 근무했는지
SELECT NAME AS 이름 , TRUNC(MONTHS_BETWEEN(SYSDATE,HIREDATE)/12) AS 근속년수 FROM temp;

SELECT SYSDATE , ADD_MONTHS(SYSDATE,5) FROM DUAL;

SELECT NEXT_DAY(SYSDATE,'일요일') FROM DUAL;
SELECT NEXT_DAY(SYSDATE,1) FROM DUAL;

SELECT LAST_DAY(SYSDATE)FROM DUAL; --이번달 마지막날을 리턴함. 

SELECT TRUNC(SYSDATE) FROM DUAL;  -- 시 분 초를 버림.

SELECT ROUND(SYSDATE)FROM DUAL; --오전오후를 기반으로  ?

SELECT ROUND(SYSDATE,'month')FROM DUAL ;--월 기반
SELECT ROUND(SYSDATE,'year')FROM DUAL; --yeqr기반


--형변환 함수  TYPE

SELECT 2+'2' FROM DUAL; --묵시적변환 
SELECT 2+TO_NUMBER('2') FROM DUAL; --명시적 변환

-- 숫자 > 문자 TO_CHAR
-- 문자 > 숫자 TO_NUMBER
-- 문자 > 날짜 TO_DATE
-- 날짜 > 문자 TO_CHAR

SELECT SYSDATE , TO_CHAR(SYSDATE,'YYYY') AS YEAR FROM DUAL;
SELECT SYSDATE , TO_CHAR(SYSDATE,'YYY') AS YEAR FROM DUAL;
SELECT SYSDATE , TO_CHAR(SYSDATE,'RRRR') AS YEAR FROM DUAL;
SELECT SYSDATE , TO_CHAR(SYSDATE,'year') AS YEAR FROM DUAL;

SELECT SYSDATE , TO_CHAR(SYSDATE,'mm') AS month,
				TO_CHAR(SYSDATE,'mon') AS month,
				TO_CHAR(SYSDATE,'month') AS month FROM DUAL;
			
SELECT SYSDATE, TO_CHAR (SYSDATE,'YYYY-MM-DD AM DAY HH:MI:SS','NLS_DATE_LANGUAGE=ENGLISH') AS 날짜 FROM DUAL; --AM/PM , DY/DAY//D/DD/DDD
			
SELECT SYSDATE, TO_CHAR (SYSDATE,'YYYY-MM-DD AM WW HH:MI:SS') AS 날짜 FROM DUAL;			



--------------------------------------decode vs case when --------------------------------------
--decoe 함수 오라클전용 if문 

--CASE DECODE 월급올려주기 manager 10% salesman5% analyst 동결 clerk 3%
SELECT ENAME ,EMPNO,JOB,SAL,DECODE(JOB,'MANAGER',SAL*1.1,'SALESMAN',SAL*1.05,'CLERK',SAL*1.03,SAL) AS "급여인상"  FROM EMP; --DECODE() 조건문

--CASE WHEN 
SELECT ENAME ,EMPNO,JOB,SAL,
CASE JOB
WHEN 'MANAGER' THEN SAL*1.1 -- WHEN JOB = 'MANAGER' THEN SAL *1.1  이것과 같음 WHEN JOB = 'MANAGER' AND 'CLERK' THEN SAL *1.1
WHEN 'SALESMAN' THEN SAL*1.05
WHEN 'CLERK' THEN SAL*1.03 
ELSE SAL 
END AS "급여인상"  
FROM EMP;

--
WITH temp AS(
SELECT 'M' gender FROM DUAL UNION ALL 
SELECT 'F' gender FROM DUAL UNION ALL
SELECT 'X' gender FROM DUAL
)
SELECT gender,DECODE(GENDER,'M','남자','F','여자','기타') AS 성별  FROM temp;
--IF(GENDER=='M'){RETURN "남자"}
--ELSE IF (GENDER=='F'){RETURN "여자"}
--ELSE {RETURN "기타"}

SELECT * FROM EMP;
 
SELECT ENAME,JOB,DECODE(ENAME,'SMITH','스미스','WARD','와드','JONES','존스','MARTIN','마틴','BLAKE','블레이크','CLARK','클락','SCOTT','스캇','KING','킹','TURNER','터너','ADAMS','아담스','JAMES','제임스','FORD','포드','MILLER','밀러','ALLEN','알렌') AS 이름 FROM EMP;

SELECT ENAME,JOB,DECODE(JOB,'CLERK','사원','SALESMAN','영업','MANAGER','관리자','ANALYST','분석가','PRESIDENT','사장') AS 직책 FROM EMP;

--DECODE 는 NULL CHECK 가능
SELECT ENAME,COMM,DECODE(COMM,NULL,'NO','YES') AS NULLCHECK FROM EMP;

SELECT * FROM EMP; 

--SAL>=2900 DIAMOND SAL>=2700 PLATINUM SAL>=2500 EMERALD SAL>=2000 GOLD ELSE SILVER
SELECT ENAME,SAL,
CASE   --AND OR 가능 
WHEN SAL >=3000 THEN 'DIAMOND'
WHEN SAL >=2500 THEN 'PLATINUM'
WHEN SAL >=2000 THEN 'GOLD'
ELSE 'SILVER'
END AS "GRADE"
FROM EMP;

SELECT EMPNO,ENAME,COMM,
CASE
	WHEN COMM IS NULL THEN 'NO'
	WHEN COMM > 0 THEN 'YES'
	--	WHEN COMM IS NOT NULL THEN 'YES'
END AS "커미션"
FROM EMP;

SELECT * FROM EMP;
--매니저가 없을때는 0000
-- 매니저의 사원번호가 75일떄는 5555
-- 매니저의 사원번호가 76일떄는 6666
-- 매니저의 사원번호가 77일떄는 7777
-- 매니저의 사원번호가 78일떄는 8888
-- 매니저의 사원번호가 79일떄는 9999

SELECT EMPNO,ENAME,MGR,
CASE 
	WHEN TRUNC(MGR/100)=75 THEN 5555
	WHEN TRUNC(MGR/100)=76 THEN 6666
	WHEN TRUNC(MGR/100)=77 THEN 7777
	WHEN TRUNC(MGR/100)=78 THEN 8888
	WHEN TRUNC(MGR/100)=79 THEN 9999
	WHEN MGR IS NULL THEN 0000
END AS "사수"
FROM EMP;

SELECT EMPNO,ENAME,MGR,
CASE 
	WHEN SUBSTR(MGR,1,2)='75' THEN '5555'
	WHEN SUBSTR(MGR,1,2)='76' THEN '6666'
	WHEN SUBSTR(MGR,1,2)='77' THEN '7777'
	WHEN SUBSTR(MGR,1,2)='78' THEN '8888'
	WHEN SUBSTR(MGR,1,2)='79' THEN '9999'
	WHEN MGR IS NULL THEN '0000'
	ELSE TO_CHAR(MGR)
END AS "사수"
FROM EMP;






