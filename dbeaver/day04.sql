--join tabel 연결해서 쓰기.
SELECT * FROM EMP;
SELECT * FROM DEPT;

SELECT * FROM EMP,DEPT ; --14*4의 56개 데이터 출력됨

--TABEL 의 ALIAS(별칭) 은 한칸띄우먄됨
SELECT * FROM EMP E,DEPT D WHERE E.DEPTNO = D.DEPTNO; -- 중복된 DEPTNO를 이용해 조건을 맞춤

--중복되는 DEPTNO 는 반드시 어디의 COLUMN 인지 적어야함.
SELECT EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,D.DEPTNO,DNAME,LOC FROM EMP E,DEPT D WHERE E.DEPTNO = D.DEPTNO ;

SELECT E.*,DNAME,LOC FROM EMP E , DEPT D WHERE E.DEPTNO =D.DEPTNO;

SELECT E.*,D.DNAME,D.LOC FROM EMP E , DEPT D WHERE E.DEPTNO =D.DEPTNO ORDER BY EMPNO;

-- INNER JOIN 등가 조인  같은 값을 찾아서  JOIN 하기  JOIN 을 쓰지않으면 보통 INNER JOIN 

-- 비등가 조인  
SELECT * FROM EMP;

SELECT * FROM SALGRADE;
-- 같다가 아닌 값이 사이에 있는경우
SELECT * FROM EMP E , SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
SELECT * FROM EMP E , SALGRADE S WHERE E.SAL >= S.LOSAL AND E.SAL <= S.HISAL;

-- 등가조인 이면서 SELF 조인  (+)가 안붙은곳이  기준임
SELECT E1.EMPNO,E1.ENAME,E1.MGR,E2.EMPNO AS MGR_NO ,E2.ENAME AS MGR_NAME  FROM EMP E1 , EMP E2 WHERE E1.MGR=E2.EMPNO(+);
SELECT E1.EMPNO,E1.ENAME,E1.MGR,E2.EMPNO AS MGR_NO ,E2.ENAME AS MGR_NAME  FROM EMP E1 , EMP E2 WHERE E1.MGR(+)=E2.EMPNO;

-- ANSI 조인 / 표준조인 

--공통인 DEPTNO 는 TABEL 명을 비워둠
-- 메인테이블 연결하는테이블  
SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,DEPTNO,D.DNAME,D.LOC FROM EMP E NATURAL JOIN DEPT D ORDER BY DEPTNO,E.EMPNO;

SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,DEPTNO,D.DNAME,D.LOC FROM EMP E JOIN DEPT D USING(DEPTNO) ORDER BY DEPTNO,E.EMPNO;
--JOIN 만 쓸경우 INNER JOIN  ON () 괄호생략가능
SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,E.DEPTNO,D.DNAME,D.LOC FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO) WHERE E.JOB ='MANAGER' ORDER BY DEPTNO,E.EMPNO;

SELECT E.ENAME,E.DEPTNO,D.DNAME,D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.JOB = 'MANAGER'; --ORACLE에서의 조인


--OUTER JOIN 
SELECT E1.EMPNO,E1.ENAME,E1.MGR,E2.EMPNO AS MGR_NO , E2.ENAME AS MGR_NAME 
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO,E1.ENAME,E1.MGR,E2.EMPNO AS MGR_NO , E2.ENAME AS MGR_NAME 
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO,E1.ENAME,D1.DEPTNO,D1.DNAME 
FROM EMP E1 CROSS JOIN DEPT D1 ORDER BY E1.EMPNO;
--FULL OUTER JOIN 다해주는것 
SELECT E1.EMPNO,E1.ENAME,D1.DEPTNO,D1.DNAME 
FROM EMP E1 FULL OUTER JOIN DEPT D1 ON E1.DEPTNO = D1.DEPTNO ORDER BY E1.EMPNO;


SELECT * FROM DEPT;
--1-1
SELECT E.DEPTNO,ENAME,DNAME,SAL FROM EMP E , DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL>2000;
-- ORACLE 방식
SELECT EMPNO,ENAME,SAL,E.DEPTNO,DNAME FROM EMP E , DEPT D WHERE E.DEPTNO = D.DEPTNO AND SAL>2000;
--표준방식 NATURAL 조인에 사용된 열은 식별자를 가질수 없음
SELECT E.EMPNO,E.ENAME,E.SAL,DEPTNO, D.DNAME FROM EMP E NATURAL JOIN DEPT D WHERE E.SAL>2000; 
--INNER JOIN시에는 식별자를 붙여야함.
SELECT E.EMPNO,E.ENAME,E.SAL,E.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D ON E.DEPTNO =D.DEPTNO WHERE E.SAL>2000; 
--1-2
SELECT E.DEPTNO,ENAME,DNAME,SAL FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO) WHERE E.SAL>2000; 
--2-1
SELECT E.DEPTNO,D.DNAME,TRUNC(AVG(SAL)),MAX(SAL),MIN(SAL),COUNT(*) FROM EMP E , DEPT D WHERE E.DEPTNO = D.DEPTNO GROUP BY E.DEPTNO,D.DNAME ;
--ORACLE 방식 ORDER BY 는 ALIAS 쓸수있다. EX)AVG_SAL 
SELECT E.DEPTNO,DNAME,TRUNC(AVG(SAL)) AS AVG_SAL,MAX(SAL),MIN(SAL),COUNT(*)  FROM EMP E , DEPT D WHERE E.DEPTNO =D.DEPTNO GROUP BY E.DEPTNO,DNAME ORDER BY DEPTNO ;
--
SELECT DEPTNO,DNAME,TRUNC(AVG(SAL)) AS AVG_SAL,MAX(SAL),MIN(SAL),COUNT(*)  FROM EMP E JOIN DEPT D USING(DEPTNO) GROUP BY DEPTNO,D.DNAME ORDER BY DEPTNO;
SELECT E.DEPTNO,DNAME,TRUNC(AVG(SAL)) AS AVG_SAL,MAX(SAL),MIN(SAL),COUNT(*)  FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO) GROUP BY E.DEPTNO,D.DNAME ORDER BY DEPTNO;
--2-2
SELECT E.DEPTNO , DNAME,TRUNC(AVG(SAL)),MAX(SAL),MIN(SAL),COUNT(*) FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO) GROUP BY E.DEPTNO,D.DNAME; 
--3
SELECT D.DEPTNO,DNAME,EMPNO,MGR,ENAME,JOB,SAL,LOC,COMM FROM EMP E FULL OUTER JOIN DEPT D ON E.DEPTNO =D.DEPTNO ORDER BY DEPTNO;
SELECT * FROM DEPT; -- DEPTNO 40 을 출력해야함.
SELECT * FROM EMP;

--오라클 방식
SELECT D.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.JOB,E.SAL FROM EMP E , DEPT D WHERE E.DEPTNO(+) = D. DEPTNO;
--표준방식
SELECT D.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.JOB,E.SAL FROM DEPT D LEFT OUTER JOIN EMP E ON(E.DEPTNO=D.DEPTNO) ORDER BY DNAME;
SELECT D.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.JOB,E.SAL FROM EMP E RIGHT OUTER JOIN DEPT D  ON(E.DEPTNO=D.DEPTNO);

--4 아래와 같이 모든부서정보,사원정보,급여등급정보,각사원의 상관정보를 부서번호,사원번호 순서로 정렬하여 출력하시옷
SELECT D.DEPTNO , D.DNAME,E.EMPNO,E.ENAME,E.MGR,E.SAL,E.DEPTNO,S.LOSAL,S.HISAL,S.GRADE,E2.EMPNO AS MGR_EMPNO,E2.ENAME AS MGR_ENAME 
FROM EMP E , DEPT D , SALGRADE S , EMP E2
WHERE E.DEPTNO(+) = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL AND E.MGR = E2.EMPNO(+);


--1번 DEPT 와 EMP JOIN 2. DEPT + EMP 와 SALGRADE JOIN 3. DEPT + EMP + SALGRADE 와 EMP E2 JOIN

--4-1
SELECT D.DEPTNO , D.DNAME,E.EMPNO,E.ENAME,E.MGR,E.SAL,E.DEPTNO
FROM EMP E RIGHT OUTER JOIN DEPT D
ON E.DEPTNO(+) = D.DEPTNO ;
--4-2
SELECT D.DEPTNO , D.DNAME,E.EMPNO,E.ENAME,E.MGR,E.SAL,E.DEPTNO,
S.LOSAL,S.HISAL,S.GRADE
FROM EMP E RIGHT OUTER JOIN DEPT D
ON E.DEPTNO(+) = D.DEPTNO 
LEFT OUTER JOIN SALGRADE S 
ON E.SAL BETWEEN S.LOSAL  AND S.HISAL ;
--4-3
SELECT D.DEPTNO , D.DNAME,E.EMPNO,E.ENAME,E.MGR,E.SAL,E.DEPTNO,
S.LOSAL,S.HISAL,S.GRADE,
E2.EMPNO AS MGR_EMPNO,E2.ENAME AS MGR_ENAME 
FROM EMP E RIGHT OUTER JOIN DEPT D
ON E.DEPTNO(+) = D.DEPTNO 
LEFT OUTER JOIN SALGRADE S 
ON E.SAL BETWEEN S.LOSAL  AND S.HISAL 
LEFT OUTER JOIN EMP E2
ON E.MGR = E2.EMPNO;

--FULL OUTER JOIN
SELECT E.EMPNO,E.ENAME,E.DEPTNO,D.DNAME 
FROM EMP E 
--LEFT OUTER JOIN DEPT D 
--RIGHT OUTER JOIN DEPT D
FULL OUTER JOIN DEPT D  -- 둘다 출력함.
ON E.DEPTNO = D.DEPTNO;


--ORACLE 은 자동 커밋 AUTO COMMIT X DEFAULT 수동커밋
--SELECT는 읽기 이기 떄문에 TABEL에 영향을 미치지 않음.
--INSERT , DELETE , UPDATE 은 TABEL에 영향을 미침. 반드시 앞의 3가지 쓸경우 COMMIT 이나 ROLLBACK 을 해야함. TRANSATION(묶음) > 카뱅 10만 > 토스 10만  이체실패시 롤백  
INSERT INTO EMP (EMPNO,ENAME) VALUES (9988,'HeoTh');
SELECT * FROM EMP;
ROLLBACK;-- 취소
COMMIT; --데이터를 확정하는것
DELETE FROM EMP WHERE ENAME = 'HeoTh';















