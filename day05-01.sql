--INSERT(C) , SELECT (R) , UPDATE(U) , DELETE(D)
--INSERT , UPDATE , DELETE 는 COMMIT과 ROLLBACK 이 동반됨.
SELECT * FROM DEPT;

CREATE TABLE TEMP_EMP AS SELECT * FROM EMP; --빈 껍데기 만드는법 조건을 맞지않게 설정
DROP TABLE TEMP_DEPT;
DROP TABLE TEMP_EMP;
SELECT * FROM TEMP_EMP;
--INSERT INTO  제약사항 NOT NULL
--문자,문자열,날짜일때 공백을 NULL 처리한다.
SELECT * FROM TEMP_DEPT;
INSERT INTO TEMP_DEPT 
VALUES (80,'FULLSTACK','');
COMMIT;
ROLLBACK;
INSERT INTO TEMP_EMP (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(9997,'YEEUN','BOSS',NULL,TO_DATE('30-04-2024','DD-MM-YYYY'),6000,1200,20);

SELECT * FROM TEMP_EMP;

--수정 UPDATE 
SELECT * FROM TEMP_DEPT;

UPDATE TEMP_DEPT SET LOC ='BUSAN' WHERE LOC = 'BUSAN';
ROLLBACK;

UPDATE TEMP_DEPT SET LOC = 'GEOJE' , DNAME = 'AAA' WHERE DEPTNO = 80;


UPDATE TEMP_DEPT SET (DNAME,LOC) = (SELECT DNAME,LOC FROM TEMP_DEPT WHERE DEPTNO = 40) WHERE DEPTNO =80;


--삭제 DELETE  조건을 반드시 걸어야함. 
SELECT * FROM TEMP_EMP;
DELETE FROM TEMP_EMP WHERE JOB = 'MANAGER';
ROLLBACK;




---
CREATE TABLE TEMP_EMP AS SELECT * FROM EMP;
CREATE TABLE TEMP_DEPT AS SELECT * FROM DEPT;
CREATE TABLE TEMP_SALGRADE AS SELECT * FROM SALGRADE;
DROP TABLE TEMP_EMP;
DROP TABLE TEMP_DEPT;
COMMIT;
--1
SELECT * FROM TEMP_DEPT;
SELECT * FROM TEMP_EMP TE INNER JOIN TEMP_DEPT TD ON TE.DEPTNO =TD.DEPTNO ;

INSERT INTO TEMP_DEPT (DEPTNO,DNAME,LOC)VALUES(50,'ORACLE','BUSAN');
INSERT INTO TEMP_DEPT VALUES(60,'SQL','ILSAN');--INSERT시 TABEL의 모든 값을 추가할경우 추가할 부분을 생략가능.
INSERT INTO TEMP_DEPT (DEPTNO,DNAME,LOC)VALUES(70,'SELECT','INCHEON');
INSERT INTO TEMP_DEPT (DEPTNO,DNAME,LOC)VALUES(80,'DML','BUNDANG');

COMMIT;
SELECT * FROM TEMP_DEPT;
--2
SELECT * FROM EMP;
CREATE TABLE CHAP10HW_EMP AS SELECT * FROM EMP;
DROP TABLE CHAP10HW_EMP;
COMMIT;
SELECT * FROM CHAP10HW_EMP;
INSERT INTO CHAP10HW_EMP VALUES(7201,'TEST_USER1','MANAGER',7788,TO_DATE('2024-01-02','YYYY-MM-DD'),4500,NULL,50);-- TABLE의 모든값을 INSERT하기때문에  VALUES 전 값 생략가능.
INSERT INTO CHAP10HW_EMP VALUES(7202,'TEST_USER2','CLERK',7201,TO_DATE('2024-02-21','YYYY-MM-DD'),1800,NULL,50); 
INSERT INTO CHAP10HW_EMP VALUES(7203,'TEST_USER3','ANALYST',7201,TO_DATE('2024-04-11','YYYY-MM-DD'),3400,NULL,60);
INSERT INTO CHAP10HW_EMP VALUES(7204,'TEST_USER4','SALESMAN',7201,TO_DATE('2024-05-31','YYYY-MM-DD'),2700,300,60);
INSERT INTO CHAP10HW_EMP VALUES(7205,'TEST_USER5','CLERK',7201,TO_DATE('2024-07-20','YYYY-MM-DD'),2600,NULL,70);
INSERT INTO CHAP10HW_EMP VALUES(7206,'TEST_USER6','CLERK',7201,'2024-09-08',2600,NULL,70);--묵시적 변환으로 TO_DATE생략가능.
INSERT INTO CHAP10HW_EMP VALUES(7207,'TEST_USER7','LECTURER',7201,'2024-10-28',2300,NULL,80);
INSERT INTO CHAP10HW_EMP VALUES(7208,'TEST_USER8','STUDENT',7201,'2024-03-09',1200,NULL,80);

INSERT INTO TEMP_EMP VALUES(7201,'TEST_USER1','MANAGER',7788,'2024-01-02',4500,NULL,50);
INSERT INTO TEMP_EMP VALUES(7202,'TEST_USER2','CLERK',7201,'2024-02-21',1800,NULL,50);
INSERT INTO TEMP_EMP VALUES(7203,'TEST_USER3','ANALYST',7201,'2024-04-11',3400,NULL,60);
INSERT INTO TEMP_EMP VALUES(7204,'TEST_USER4','SALESMAN',7201,'2024-05-31',2700,300,60);
INSERT INTO TEMP_EMP VALUES(7205,'TEST_USER5','CLERK',7201,'2024-07-20',2600,NULL,70);
INSERT INTO TEMP_EMP VALUES(7206,'TEST_USER6','CLERK',7201,'2024-09-08',2600,NULL,70);
INSERT INTO TEMP_EMP VALUES(7207,'TEST_USER7','LECTURER',7201,'2024-10-28',2300,NULL,80);
INSERT INTO TEMP_EMP VALUES(7208,'TEST_USER8','STUDENT',7201,'2024-03-09',1200,NULL,80);
SELECT * FROM TEMP_EMP;
ROLLBACK;
--3
SELECT AVG(SAL) FROM TEMP_EMP WHERE DEPTNO = 50;
SELECT * FROM TEMP_EMP WHERE SAL>(SELECT AVG(SAL) FROM TEMP_EMP WHERE DEPTNO = 50);
UPDATE TEMP_EMP SET DEPTNO=70 WHERE SAL>(SELECT AVG(SAL) FROM TEMP_EMP WHERE DEPTNO = 50);
SELECT * FROM TEMP_EMP;
COMMIT;
ROLLBACK;
--4
SELECT MIN(HIREDATE) FROM TEMP_EMP WHERE DEPTNO=60;
SELECT * FROM TEMP_EMP WHERE HIREDATE > (SELECT MIN(HIREDATE) FROM TEMP_EMP WHERE DEPTNO=60);
UPDATE TEMP_EMP SET SAL=SAL*1.1,DEPTNO=80 WHERE HIREDATE > (SELECT MIN(HIREDATE) FROM TEMP_EMP WHERE DEPTNO=60);
SELECT * FROM TEMP_EMP;
ROLLBACK;

--5
--PRIMARY KEY 는 UNIQUE한것
SELECT EMPNO FROM TEMP_EMP TE INNER JOIN TEMP_SALGRADE TG ON(TE.SAL BETWEEN TG.LOSAL AND TG.HISAL) WHERE GRADE = 5;
DELETE FROM TEMP_EMP WHERE EMPNO IN(SELECT EMPNO FROM TEMP_EMP TE INNER JOIN TEMP_SALGRADE TG ON(TE.SAL BETWEEN TG.LOSAL AND TG.HISAL) WHERE GRADE = 5);
SELECT * FROM TEMP_EMP;
ROLLBACK;

--TRANSACTION
--하나의작업단위    카카오뱅크 >> 토스  카카오뱅크의에서 돈-- 토스에서 돈++ 는 하나의작업으로 묶여야한다.  
--COMMIT(AUTO_COMMIT)/ROLLBACK

SELECT * FROM TEMP_EMP;

DELETE FROM TEMP_EMP WHERE EMPNO = 7202;
--C(CREATE) 는 생성하자마자 바로 COMMIT된다. 
--U(UPDATE)D(DELETE) 이후 COMMIT이나 ROLLBACK 을 하지않으면 다른세션에서 UPDATE , DELETE할때 LOCK이 걸린다. 

--실무에서는  DB를 여러개 만들어둔다. 

--SQL (STRUCTURED QUERY LANGUAGE) 
--DCL (DATA CONTROL LANGUAGE) 데이터 제어어 GRANT , REVOKE
--DML (DATA MANIPULATION LANGUAGE) 데이터 조작어
--DDL (DATA DEFINITION LANGUAGE) 데이터 정의어 CREATE , ALTER , DROP , RENAME , TRUNCATE
--TCL (TRANSACTION CONTROL LANGUAGE ) COMMIT , ROLLBACK

--TABEL 생성 컬럼 정의 
--TABLE 명은 문자로 시작해야하고 COLUMN명은 중복이안되고, 영어로쓴다. (한글도 되지만 쓰지않는다) , 특수문자도 가능 _ , # , $ 등 보통 쓰지않는다 
SELECT * FROM EMP;
CREATE TABLE DDL_EMP(
	EMPNO NUMBER(4) NOT NULL, --4자리 숫자  제약사항 NOT NULL  
	ENAME VARCHAR2(10) NOT NULL, --10자리 문자 VARCHAR VARCHAR2 는 데이터타입이고 VATCHAR는 잘쓰지않는다.
	-- CHAR(빈공간은 공백으로 채운다) 는 값을 고정적으로 입력해야하고 VARCHAR는 값을 유동적으로 입력해도 된다.(가변문자열)
	JOB VARCHAR2(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(10,2), --,2는 소숫점자릿수 , 소숫점자리수를 포함하여 10자리 
	COMM NUMBER(10,2),
	DEPTNO NUMBER (3)	
	--DEPTNO NUMBER   아무숫자나 다들어감  소수는 127자리까지만
);
SELECT * FROM DDL_EMP;
--VARCAHR2 (10) 영어만 해당
--NVARCHAR2 (10) 문자열의 길이로 판단
INSERT INTO DDL_EMP VALUES (11111,'TAEHOON','STUDENT',NULL,TO_DATE(SYSDATE),3000,NULL,30,'010-0000-0000');
COMMIT;

--ALTER TABLE COLUMN 생성
ALTER TABLE DDL_EMP ADD HP VARCHAR2(13); -- COLUMN 추가 , 값이 NULL로 들어감.
ALTER TABLE DDL_EMP RENAME COLUMN HP TO PHONE_NUMBER; --COLUMN 이름바꾸기
ALTER TABLE DDL_EMP RENAME TO DDL_EMP; --TABLE 이름바꾸기
ALTER TABLE DDL_EMP MODIFY EMPNO NUMBER(6); --COLUMN 의 TYPE 변경  기존데이터값들을 잘보고 골라야함. 값을 줄이려면 데이터값들이 비어있어야함.
ALTER TABLE DDL_EMP DROP COLUMN PHONE_NUMBER;
SELECT * FROM DDL_EMP;

--DROP TABLE 은 테이블을 삭제하므로 데이터들도 삭제된다
--TRUNCATE 데이터만 지우기 
TRUNCATE TABLE DDL_EMP; -- 조건없는 DELETE 와 같다 ROLLBACK 안됨. 
SELECT * FROM DDL_EMP;

--1
CREATE TABLE PRACTICE_EMP (
	EMPNO NUMBER(4),
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER (4),
	HIREDATE DATE,
	SAL NUMBER(7,2),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2)
);
SELECT * FROM PRACTICE_EMP;
--2
ALTER TABLE PRACTICE_EMP ADD BIGO VARCHAR2(20);
SELECT * FROM PRACTICE_EMP;
--3
ALTER TABLE PRACTICE_EMP MODIFY BIGO VARCHAR2(30);
SELECT * FROM PRACTICE_EMP;
--4
ALTER TABLE PRACTICE_EMP RENAME COLUMN BIGO TO REMARK;
SELECT * FROM PRACTICE_EMP;

DROP TABLE PRACTICE_EMP;

CREATE TABLE NUM_TABLE (
	NUM01 NUMBER,
	NUM02 NUMBER(3),
	NUM03 NUMBER(3,2),
	NUM04 NUMBER(5,2),
	NUM05 NUMBER(7,1),
	NUM06 NUMBER(7,-1),
	NUM07 NUMBER(4,5),
	NUM08 NUMBER(4,7)
	NUM09 NUMBER(2,2)
);
TRUNCATE TABLE NUM_TABLE;
SELECT * FROM NUM_TABLE;
--NUM01은 아무숫자 써도됨.
ALTER TABLE NUM_TABLE ADD NUM09 NUMBER(2,2);
INSERT INTO NUM_TABLE (NUM01)VALUES(999999999.99999999999999999999);
INSERT INTO NUM_TABLE (NUM02)VALUES(123.52222222222);
INSERT INTO NUM_TABLE (NUM03)VALUES(1.23);
INSERT INTO NUM_TABLE (NUM03)VALUES(1.12);
INSERT INTO NUM_TABLE (NUM04)VALUES(123.23);
INSERT INTO NUM_TABLE (NUM04)VALUES(123.235555555555555);
INSERT INTO NUM_TABLE (NUM05)VALUES(123456.12);
INSERT INTO NUM_TABLE (NUM05)VALUES(123456.12345555555555555);
INSERT INTO NUM_TABLE (NUM06)VALUES(1234567.123456); -- -1자리를 반올림함. 
INSERT INTO NUM_TABLE (NUM06)VALUES(12345678.123456); -- -1자리를 반올림함. 
INSERT INTO NUM_TABLE (NUM07)VALUES(0.01234);
INSERT INTO NUM_TABLE (NUM08)VALUES(0.000234567);
INSERT INTO NUM_TABLE (NUM09)VALUES(0.12);
INSERT INTO NUM_TABLE (NUM09)VALUES(0.1234567899999999999999999999);

--VIEW 도 테이블이다. 가상테이블이라고도 함.
--VIEW 는 조회용으로만 사용한다. VIEW에는 궂이 INSERT UPDATE DELETE를 하지않는다.

CREATE VIEW VIEW_EMP_20 AS SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP WHERE DEPTNO = 20;

--VIEW를 보는 명령어 
SELECT * FROM USER_VIEWS;

--백화점의 고객정보,이름 주소,비용 ,직업
--SUBQUERY의 FROM절에 사용되는 쿼리를 INLINE VIEW 라고 한다.
SELECT * FROM VIEW_EMP_20;
SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP WHERE DEPTNO=20;  --INLINE VIEW
--VIEW 삭제
DROP VIEW VIEW_EMP_20;
--SAL 상위 5명 뽑기
SELECT * FROM EMP ORDER BY SAL DESC;
SELECT * FROM EMP WHERE ROWNUM <6 ORDER BY SAL DESC;
SELECT ROWNUM, E.* FROM EMP E;

SELECT ROWNUM,E.* FROM (SELECT * FROM EMP ORDER BY SAL DESC) E WHERE ROWNUM <6;

--SEQUENCE
--ORACLE은 자동증가 없음.
INSERT INTO EMP (EMPNO,ENAME) VALUES ((SELECT MAX(EMPNO+1 FROM EMP);

SELECT * FROM EMP;

CREATE SEQUENCE EMP_SEQ
INCREMENT BY 1
START WITH 1
MAXVALUE  10
MINVALUE 1
NOCYCLE
CACHE 5;  --CACHE는 미리만들어두는 SEQUENCE 갯수

--증가한 값을 다시 처음부터 사용안됨.
SELECT EMP_SEQ.NEXTVAL FROM DUAL;

SELECT * FROM EMP;

INSERT INTO EMP (EMPNO,ENAME) VALUES (EMP_SEQ).NEXTVAL,'';
ROLLBACK;
SELECT EMPNO,ENAME,SAL, RANK() OVER(ORDER BY SAL DESC) FROM EMP;  -- 중복시 카운트
SELECT EMPNO,ENAME,SAL, DENSE_RANK() OVER(ORDER BY SAL DESC) FROM EMP; --중복시 카운트 안함

SELECT * FROM EMP INNER JOIN 
(SELECT EMPNO,ENAME,SAL, DENSE_RANK() OVER(ORDER BY SAL DESC) AS R FROM EMP) RANKING 
ON EMP.EMPNO = RANKING.EMPNO 
WHERE RANKING.R<=5;

SELECT * FROM EMP INNER JOIN 
(SELECT EMPNO,ENAME,SAL, RANK() OVER(ORDER BY SAL DESC) AS R FROM EMP) RANKING 
ON EMP.EMPNO = RANKING.EMPNO 
WHERE RANKING.R<=5;

CREATE SEQUENCE EMP_SEQ01
INCREMENT BY 1
START WITH 1
MAXVALUE  10
MINVALUE 1
CYCLE
CACHE 5;

SELECT EMP_SEQ01.NEXTVAL FROM DUAL;
ROLLBACK;

SELECT EMP_SEQ01.CURRVAL FROM DUAL;

SELECT * FROM USER_SEQUENCES;
SELECT * FROM USER_IND_COLUMNS;


--INDEX는 검색을 빠르게하기위해 쓰는것.
--SELECT 속도가 빨라짐.
--데이터가 엄청 많을때 사용하면 좋다.
-- primary key 제약사항을 만들면 자동으로 indexing해줌.
CREATE INDEX IDX_EMP_NO ON EMP(SAL); --장점만 있는것은 아니다.

SELECT * FROM emp;

--5
CREATE TABLE EMPIDX AS SELECT * FROM EMP;
CREATE INDEX IDX_EMPIDX_EMPNO ON EMPIDX(EMPNO);
SELECT * FROM USER_IND_COLUMNS;
--6
DROP VIEW EMPIDX_OVER15K;
CREATE VIEW EMPIDX_OVER15K AS SELECT EMPNO,ENAME,JOB,DEPTNO,SAL,COMM FROM EMPIDX WHERE SAL>1500;
SELECT EMPNO,ENAME,JOB,DEPTNO,SAL,DECODE(COMM,NULL,'X','O') AS COMM FROM EMPIDX_OVER15K;
--7
CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;
SELECT * FROM DEPTSEQ;

CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT BY 1 
START WITH 1
MAXVALUE 99
MINVALUE 1
NOCYCLE 
NOCACHE

INSERT INTO DEPTSEQ (DEPTNO,DNAME,LOC) VALUES(SEQ_DEPTSEQ.NEXTVAL,NULL,NULL);
ROLLBACK;
SELECT * FROM DEPTSEQ;




